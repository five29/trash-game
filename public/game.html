<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ocean Cleanup Game</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/addons/p5.sound.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    #startOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 48px;
      font-family: sans-serif;
      z-index: 1000;
    }
    #startOverlay.hidden {
      display: none;
    }
video {
  position: absolute !important;
  left: -9999px !important;
  top: -9999px !important;
  pointer-events: none !important;
  z-index: -1 !important;
}

html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  
}
  </style>
<script>
function handleStartClick() {
  if (!bgMusicLoaded) return;
  const overlay = document.getElementById('startOverlay');
  overlay.classList.add('hidden');
  if (bgMusic && !bgMusic.isPlaying()) {
    bgMusic.setVolume(0.4);
    bgMusic.loop();
  }
  loop();
  gameStartFrame = frameCount;
}
</script>
</head>
<body>
<div id="startOverlay" onclick="handleStartClick()">Loading...</div>
<script>
let socket;
let players = {};
let trash = [];
let trashImages = [];
let particles = [];
let bubbles = [];
let fish = [];
let fishImages = [];
let totalTrash = 300;
let netImage;
let backgroundImg;
let oceanSaved = false;
let savedTimer = 0;
let showScoreboard = false;
let countdown = 180;
let splash = true;
let shimmerX = 0;
let bgMusic;
let collectSound;
let gameTimer = 240; // 2 minutes
let gameOver = false;
let gameOverTimer = 0;
let gameStartFrame;
let gameOverVideo;
let gameOverVideoStarted = false;
let bgMusicLoaded = false;
let showIntroVideo = false;
let introVideoPlayed = false;
let introVideo;
let grime = 1;

// Center "no-go" zone (for QR code)
// Adjust radius to fit your QR image, e.g., 200â€“300px
const qrZoneRadius = 240;
const qrZoneX = 4096 / 2;
const qrZoneY = 4096 / 2;

function handleStartClick() {
  if (!bgMusicLoaded) return;
  const overlay = document.getElementById('startOverlay');
  overlay.classList.add('hidden');
  if (bgMusic && !bgMusic.isPlaying()) {
    bgMusic.setVolume(0.4);
    bgMusic.loop();
  }
  loop();
  gameStartFrame = frameCount;
}

function preload() {
  netImage = loadImage('net.png');
  backgroundImg = loadImage('background.png');
  for (let i = 1; i <= 10; i++) {
    trashImages.push(loadImage(`trash${i}.png`));
  }
  // Load fish images
  fishImages = [];
  for (let i = 1; i <= 6; i++) {
    let fishImg = loadImage(`fish${i}.png`, (img) => {
      console.log(`Successfully loaded fish image ${i}:`, {
        width: img.width,
        height: img.height
      });
      fishImages[i-1] = img;
      if (i === 6) {
        generateFish();
      }
    });
  }
  soundFormats('mp3', 'wav');
  bgMusic = loadSound('background-music.mp3', () => {
    bgMusicLoaded = true;
    document.getElementById('startOverlay').innerText = 'Click to Start';
  });
collectSound = loadSound('collect.wav', () => {
  collectSound.setVolume(0.09); // Set between 0.0 and 1.0 (try 0.25 or 0.15 for quiet)
});
}


function setup() {
  createCanvas(4096, 4096);
  introVideo = createVideo('gameover.mp4');
  introVideo.size(4096, 4096);
  introVideo.hide();
  socket = io();
  spawnTrash();
  noLoop();
  gameOverVideo = createVideo('gameover.mp4');
  gameOverVideo.size(4096, 4096);
  gameOverVideo.hide(); // Hide it by default, we'll show it only at game over

  // Wait for images to load before generating fish
  setTimeout(() => {
    if (fishImages.length === 6) {
      generateFish();
    }
  }, 1000);

  socket.on('playerJoined', ({ id, name }) => {
    // Generate a random color
    const color = [random(255), random(255), random(255)];
    
    players[id] = {
      color: color,
      name: name,
      score: 0,
      x: width / 2,
      y: height / 2,
      targetX: width / 2,
      targetY: height / 2,
      alpha: 0
    };
    // Make the player visible
    players[id].alpha = 255;
    splash = false;
  });

  socket.on('updateGame', ({ id, move }) => {
    if (players[id]) {
      players[id].targetX = move.x * width;
      players[id].targetY = move.y * height;
      console.log(`Player ${id} moved to: ${move.x}, ${move.y}`);
    }
  });

  socket.on('scoreUpdate', ({ id, score }) => {
    if (players[id]) {
      players[id].score = score;
    }
  });

  // === ADD THIS HANDLER TO REMOVE PLAYER ON DISCONNECT ===
  socket.on('playerLeft', (id) => {
    delete players[id];
  });

  // ...rest of your setup() function (if you have more below)
}


function draw() {
  if (!gameStartFrame) gameStartFrame = frameCount;
  let timeElapsed = Math.floor((frameCount - gameStartFrame) / 60);
  let timeLeft = max(0, gameTimer - timeElapsed);

  clear();
  push();
  drawingContext.save();
  drawingContext.beginPath();
  drawingContext.arc(width / 2, height / 2, height / 2, 0, TWO_PI);
  drawingContext.clip();

  let progress = 1 - (trash.length / totalTrash);
  const playerCount = Object.keys(players).length;
  let grimeRate = constrain(trash.length / totalTrash, 0, 1);
  let rate = map(grimeRate, 0, 1, 180, 60) - playerCount * 10;
  rate = constrain(rate, 30, 300);

  
  if (backgroundImg) {
    imageMode(CORNER);
    image(backgroundImg, 0, 0, width, height);
  } else {
    background(0, 100, 200);
  }

  grime = lerp(grime, constrain(trash.length / totalTrash, 0, 1), 0.05);
let fogColor = lerpColor(color(5, 35, 10, 255), color(0, 180, 255, 0), 1 - grime);
  noStroke();
  fill(fogColor);
  rect(0, 0, width, height);

  updateBubbles();
  updateParticles();

  for (let f of fish) {
    // Use a random fish image
    let fishImage = fishImages[f.imageIndex];
    if (fishImage && fishImage.width > 0 && fishImage.height > 0) {
      // Scale the image based on the fish's size
      let scale = f.size / fishImage.width;
      push();
      translate(f.x, f.y);
      rotate(f.rotation);
      image(fishImage, 0, 0, fishImage.width * scale, fishImage.height * scale);
      pop();
    } else {
      console.log('Invalid fish image:', f.imageIndex, fishImage);
    }

    // Update fish position
    if (f.imageIndex === 0) { // Crab (index 0)
      // Stay static on the ocean floor
      let centerX = width / 2;
      let centerY = height / 2;
      let radius = height / 2 - 100;
      
      // Keep crab on the edge
      let angle = atan2(f.y - centerY, f.x - centerX);
      f.x = centerX + cos(angle) * radius;
      f.y = centerY + sin(angle) * radius;
      
      // Keep rotation facing forward
      f.rotation = angle + PI/2; // Face forward
    } else if (f.imageIndex === 1) { // Eel (index 1)
      // Create subtle wavy effect for eel
      
      // Add subtle wavy motion
      let waveOffset = frameCount * 0.05; // Slower wave speed
      f.y += sin(waveOffset) * 2; // Smaller up/down wave
      f.x += cos(waveOffset) * 1.5; // Smaller side-to-side wave
      
      // Add subtle wavy rotation
      f.rotation = f.rotation + sin(waveOffset) * 0.05;
      
      // Keep eel within bounds
      let centerX = width / 2;
      let centerY = height / 2;
      let radius = height / 2 - 100;
      let distFromCenter = dist(f.x, f.y, centerX, centerY);
      if (distFromCenter > radius) {
        let angle = random(TWO_PI);
        let r = random(radius);
        f.x = centerX + cos(angle) * r;
        f.y = centerY + sin(angle) * r;
        f.rotation = angle + random(-PI/4, PI/4);
      }
    } else if (f.imageIndex === 2 || f.imageIndex === 4) { // Fish 3 and 5 (index 2 and 4)
      // Move horizontally from left to right with natural movement
      f.x += f.speed;
      f.y += random(-1, 1); // Small up/down movement
      f.rotation = 0; // Face forward
      
      if (f.x > width) {
        f.x = 0; // Reset to left side when off screen
        f.y = random(height * 0.2, height * 0.8); // Random y position in middle of screen
      }
    } else {
      // Normal fish movement
      f.x += f.speed * cos(f.rotation);
      f.y += f.speed * sin(f.rotation);
      f.rotation += f.rotationSpeed;
      
      let centerX = width / 2;
      let centerY = height / 2;
      let radius = height / 2 - 100;
      let distFromCenter = dist(f.x, f.y, centerX, centerY);
      if (distFromCenter > radius) {
        let angle = random(TWO_PI);
        let r = random(radius);
        f.x = centerX + cos(angle) * r;
        f.y = centerY + sin(angle) * r;
        f.rotation = angle + random(-PI/4, PI/4); // Set rotation to face direction of movement
      }
    }
  }

  while (fish.length < 20) {
    let angle = random(TWO_PI);
    let r = random(height / 2 - 100);
    let x = width / 2 + cos(angle) * r;
    let y = height / 2 + sin(angle) * r;
    fish.push({
      x: x,
      y: y,
      speed: random(0.5, 1.5),
      size: random(40, 80),
      imageIndex: floor(random(fishImages.length)),
      rotation: random(TWO_PI),
      rotationSpeed: random(-0.02, 0.02)
    });
  }

  imageMode(CENTER);
  for (let t of trash) {
    let floatY = sin(frameCount * 0.05 + t.floatOffset) * 5;

noTint();
image(t.img, t.x, t.y + floatY, t.size, t.size);

    noTint();
    image(t.img, t.x, t.y + floatY, t.size, t.size);
  }

  for (let id in players) {
    let p = players[id];
    let centerX = width / 2;
    let centerY = height / 2;
    let radius = height / 2 - 150;
    let targetDist = dist(p.targetX, p.targetY, centerX, centerY);
    if (targetDist > radius) {
  let angle = atan2(p.targetY - centerY, p.targetX - centerX);
  p.targetX = centerX + cos(angle) * radius;
  p.targetY = centerY + sin(angle) * radius;
}

// ---- QR CODE "NO GO" ZONE CHECK ----
let distToQR = dist(p.targetX, p.targetY, qrZoneX, qrZoneY);
if (distToQR < qrZoneRadius + 60) { // 60 is half your net's size, adjust if needed
  let angle = atan2(p.targetY - qrZoneY, p.targetX - qrZoneX);
  p.targetX = qrZoneX + cos(angle) * (qrZoneRadius + 60);
  p.targetY = qrZoneY + sin(angle) * (qrZoneRadius + 60);
}

    p.x = lerp(p.x, p.targetX, 0.1);
    p.y = lerp(p.y, p.targetY, 0.1);
    if (p.alpha < 255) p.alpha += 5;

    if (frameCount % 6 === 0) {
      bubbles.push({ x: p.x + random(-10, 10), y: p.y + 30, size: random(10, 20), life: 60, color: [200, 255, 255] });
    }
    if (frameCount % 5 === 0) {
      particles.push({ x: p.x, y: p.y, life: 60, color: p.color });
    }

    // Draw player
    push();
    translate(p.x, p.y);
    
    // Draw solid colored circle around net
    fill(p.color[0], p.color[1], p.color[2], 150); // Semi-transparent fill
    noStroke();
    ellipse(0, 0, 120, 120);
    
    // Draw net
    tint(255, p.alpha);
    image(netImage, 0, 0, 100, 100);
    noTint();
    
    // Draw name
    fill(255, p.alpha);
    noStroke();
    textAlign(CENTER);
    textSize(32);
    textStyle(BOLD);
    text(p.name, 0, -70);
    pop();

    for (let i = trash.length - 1; i >= 0; i--) {
  let t = trash[i];
  if (dist(p.x, p.y, t.x, t.y) < (50 + t.size / 2)) {
    // ---- PARTICLE BURST EFFECT ----
    for (let j = 0; j < 20; j++) {
      let angle = random(TWO_PI);
      let speed = random(4, 10);
      particles.push({
        x: t.x,
        y: t.y,
        dx: cos(angle) * speed,
        dy: sin(angle) * speed,
        life: 30,
        color: [random(180,255), random(180,255), 0]
      });
    }
    // ------------------------------
    trash.splice(i, 1);
if (collectSound && collectSound.isLoaded()) collectSound.play();
    socket.emit('tryCollectTrash');
  }
}

  }

  let topPlayer = Object.values(players).sort((a, b) => b.score - a.score)[0];
  if (topPlayer) {
    fill(255);
    textAlign(CENTER, CENTER);
    textSize(40);
    text(`Leader: ${topPlayer.name}`, width / 2, height - 260);
  }
// Draw countdown timer (flipped upside down)
push();
translate(width / 2, 160);
rotate(PI); // 180 degrees
fill(255);
textAlign(CENTER, CENTER);
textSize(70);
text(`${timeLeft}`, 0, 0);
pop();

// Draw countdown timer at the BOTTOM (right-side up)
push();
translate(width / 2, height - 160);
fill(255);
textAlign(CENTER, CENTER);
textSize(70);
text(`${timeLeft}`, 0, 0);
pop();

  if (!oceanSaved && trash.length === 0) {
  oceanSaved = true;
  savedTimer = frameCount;

  // Immediately trigger game over logic
  gameOver = true;
  gameOverTimer = frameCount;
}

  if (oceanSaved && frameCount > savedTimer + 60) {
    showScoreboard = true;
    savedTimer = frameCount;
  }

  if (showScoreboard) {
    drawScoreboard();
    if (frameCount > savedTimer + 120) { // Hide scoreboard after 2 seconds
      showScoreboard = false;
    }
  }
  drawingContext.restore();
  pop();

  if (timeLeft === 0 && !gameOver) {
    gameOver = true;
    gameOverTimer = frameCount;
  }

if (gameOver && frameCount - gameOverTimer < 1800) {
  // --- SHOW the game over video ---
  if (gameOverVideo) {
    gameOverVideo.show();
    gameOverVideo.volume(0); // Mute
    gameOverVideo.loop();
    image(gameOverVideo, 0, 0, width, height);
  }

  // --- Draw the overlay and text at the bottom half ---
  push();
  fill(0, 0, 0, 60);
  rect(0, 0, width, height);
  fill(255);

  let baseY = height * 0.75; // Start at 75% down the canvas

  textSize(100);
  textAlign(CENTER, CENTER);
  text("GAME OVER", width / 2, baseY);

  let topPlayer = Object.values(players).sort((a, b) => b.score - a.score)[0];
  if (topPlayer && topPlayer.name) {
    textSize(55);
    fill(255, 215, 0); // Gold color for winner
    text(`Winner: ${topPlayer.name}`, width / 2, baseY + 70);
  }

  textSize(40);
  fill(255);
  let secondsLeft = Math.ceil((1800 - (frameCount - gameOverTimer)) / 60);
  text(`Next game starts in ${secondsLeft}`, width / 2, baseY + 140);
  pop();

} else if (gameOver && frameCount - gameOverTimer >= 1800) {
  // After Game Over is done, stop and hide the video!
  if (gameOverVideo) {
    gameOverVideo.stop();
    gameOverVideo.hide();
    gameOverVideo.time(0);
  }
  gameOverVideoStarted = false; // <-- reset flag!
  socket.emit('kickAll');
  // Reset game state
  gameOver = false;
  oceanSaved = false;
  showScoreboard = false;
  savedTimer = 0;
  gameStartFrame = frameCount;
  trash = [];
  spawnTrash();
  particles = [];
  bubbles = [];
  fish = [];
  generateFish();
}

}

function spawnTrash() {
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = height / 2 - 100;
  // These should match your QR zone constants:
  const qrZoneRadius = 240;  // Same value as step 1!
  const qrZoneX = centerX;
  const qrZoneY = centerY;

  // This loop keeps trying until all trash is spawned (outside QR zone)
  while (trash.length < totalTrash) {
    let angle = random(TWO_PI);
    let r = random(radius);
    let x = centerX + cos(angle) * r;
    let y = centerY + sin(angle) * r;
    let distToQR = dist(x, y, qrZoneX, qrZoneY);
    if (distToQR > qrZoneRadius + 50) { // "50" is a little safety margin
      trash.push({
        x: x,
        y: y,
        size: random(80, 60),
        img: random(trashImages),
        floatOffset: random(1000)
      });
    }
    // If too close to QR, it just tries again until enough trash is made
  }
}


function generateFish() {
  fish = [];
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = height / 2 - 100;

  // --- Double the crabs (16 instead of 8) ---
  for (let i = 0; i < 16; i++) {
    let angle = i * (TWO_PI / 16); // Evenly spaced around the circle
    let x = centerX + cos(angle) * radius;
    let y = centerY + sin(angle) * radius;
    fish.push({
      x: x,
      y: y,
      speed: 0.5,
      size: random(30, 50),
      imageIndex: 0, // Crab image
      rotation: angle + PI / 2,
      rotationSpeed: 0
    });
  }

  // --- Double the amount of fish3.png (index 2) ---
  for (let i = 0; i < 24; i++) { // was 12, now 24
    let angle = random(TWO_PI);
    let r = random(radius);
    let x = centerX + cos(angle) * r;
    let y = centerY + sin(angle) * r;
    fish.push({
      x: x,
      y: y,
      speed: random(0.5, 1.5),
      size: random(40, 70),
      imageIndex: 2, // fish3.png
      rotation: angle,
      rotationSpeed: 0
    });
  }

  // --- Double the amount of fish5.png (index 4) ---
  for (let i = 0; i < 24; i++) { // was 12, now 24
    let angle = random(TWO_PI);
    let r = random(radius);
    let x = centerX + cos(angle) * r;
    let y = centerY + sin(angle) * r;
    fish.push({
      x: x,
      y: y,
      speed: random(0.5, 1.5),
      size: random(40, 70),
      imageIndex: 4, // fish5.png
      rotation: angle,
      rotationSpeed: 0
    });
  }

  // --- Double the amount of other random fish (was 6, now 12) ---
  for (let i = 0; i < 12; i++) {
    let angle = random(TWO_PI);
    let r = random(radius);
    let x = centerX + cos(angle) * r;
    let y = centerY + sin(angle) * r;

    // Random image index (but skip 0, the crab, and avoid 2 and 4 which are already handled)
    let possibleIndexes = [1, 3, 5];
    let imageIndex = possibleIndexes[floor(random(possibleIndexes.length))];
    let sizeRange = random(40, 80);

    fish.push({
      x: x,
      y: y,
      speed: random(0.5, 1.5),
      size: sizeRange,
      imageIndex: imageIndex,
      rotation: angle,
      rotationSpeed: random(-0.01, 0.01)
    });
  }

  console.log('Generated fish:', fish);

  // Helper to spawn fish but SKIP the QR zone
  function pushFish(count, imageIndex, sizeMin, sizeMax) {
    let attempts = 0;
    let added = 0;
    while (added < count && attempts < count * 8) {
      let angle = random(TWO_PI);
      let r = random(radius);
      let x = centerX + cos(angle) * r;
      let y = centerY + sin(angle) * r;
      if (dist(x, y, qrZoneX, qrZoneY) > qrZoneRadius + 60) {
        fish.push({
          x: x,
          y: y,
          speed: random(0.5, 1.5),
          size: random(sizeMin, sizeMax),
          imageIndex: imageIndex,
          rotation: angle,
          rotationSpeed: 0
        });
        added++;
      }
      attempts++;
    }
  }

  // Add LOTS of fish3.png (index 2)
  pushFish(18, 2, 40, 70);

  // Add LOTS of fish5.png (index 4)
  pushFish(18, 4, 40, 70);

  // Add a few other random fish for variety (skip crab)
  let otherFishCount = 6;
  let attempts = 0, added = 0;
  while (added < otherFishCount && attempts < otherFishCount * 10) {
    let angle = random(TWO_PI);
    let r = random(radius);
    let x = centerX + cos(angle) * r;
    let y = centerY + sin(angle) * r;
    if (dist(x, y, qrZoneX, qrZoneY) > qrZoneRadius + 60) {
      let imageIndex = floor(random(1, fishImages.length));
      let sizeRange = random(40, 80);
      fish.push({
        x: x,
        y: y,
        speed: random(0.5, 1.5),
        size: sizeRange,
        imageIndex: imageIndex,
        rotation: angle,
        rotationSpeed: random(-0.01, 0.01)
      });
      added++;
    }
    attempts++;
  }

  console.log('Generated fish:', fish);
}


function updateBubbles() {
  for (let i = bubbles.length - 1; i >= 0; i--) {
    let b = bubbles[i];
    fill(b.color[0], b.color[1], b.color[2], map(b.life, 0, 60, 0, 180));
    noStroke();
    ellipse(b.x, b.y, b.size);
    b.y -= 0.5;
    b.size *= 0.98;
    b.life -= 1;
    if (b.life <= 0) {
      bubbles.splice(i, 1);
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    fill(p.color[0], p.color[1], p.color[2], map(p.life, 0, 30, 0, 255));
    noStroke();
    ellipse(p.x, p.y, 8, 8);
    // Move sparkle if has dx/dy (sparkle burst)
    if ('dx' in p) p.x += p.dx;
    if ('dy' in p) p.y += p.dy;
    if ('dx' in p) p.dx *= 0.85;
    if ('dy' in p) p.dy *= 0.85;
    p.life -= 1;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}
</script>

<img 
  id="game-overlay-img"
  src="overlay.png"
  style="
    position: absolute;
    left: 0;
    top: 0;
    width: 4096px;
    height: 4096px;
    pointer-events: none;
    z-index: 50000;
    user-select: none;"
  alt="QR Overlay" />
</body>
</html>
