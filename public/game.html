<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ocean Cleanup Game</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
<script>
let socket;
let players = {};
let trash = [];
let trashImages = [];
let particles = [];
let fish = [];
let totalTrash = 50;
let netImage;
let backgroundImg;
let oceanSaved = false;
let savedTimer = 0;
let showScoreboard = false;
let countdown = 30;
let sunlightAlpha = 0;

function preload() {
  netImage = loadImage('net.png');
  backgroundImg = loadImage('background.png'); // ðŸ‘ˆ your image here
  for (let i = 1; i <= 6; i++) {
    trashImages.push(loadImage(`trash${i}.png`));
  }
}

function setup() {
  createCanvas(3840, 2160);
  socket = io();
  spawnTrash();
  generateFish();

  socket.on('playerJoined', ({ id, name }) => {
    players[id] = {
      color: [random(255), random(255), random(255)],
      name: name,
      score: 0,
      x: width / 2,
      y: height / 2,
      targetX: width / 2,
      targetY: height / 2
    };
  });

  socket.on('updateGame', ({ id, move }) => {
    if (players[id]) {
      players[id].targetX = move.x * width;
      players[id].targetY = move.y * height;
    }
  });

  socket.on('scoreUpdate', ({ id, score }) => {
    if (players[id]) {
      players[id].score = score;
    }
  });
}

function spawnTrash() {
  trash = [];
  for (let i = 0; i < totalTrash; i++) {
    trash.push({
      x: random(width),
      y: random(height),
      size: random(40, 60),
      img: random(trashImages),
      floatOffset: random(1000)
    });
  }
}

function generateFish() {
  fish = [];
  for (let i = 0; i < 20; i++) {
    fish.push({
      x: random(width),
      y: random(height),
      speed: random(0.5, 1.5),
      size: random(40, 80),
      color: color(random(100, 255), random(100, 255), random(100, 255))
    });
  }
}

function draw() {
  let progress = 1 - (trash.length / totalTrash);

  // Background image
  if (backgroundImg) {
    imageMode(CORNER); // ðŸ‘ˆ Fixes scaling issue
    image(backgroundImg, 0, 0, width, height);
  } else {
    let murkyColor = color(30, 60, 40);
    let clearColor = color(0, 180, 255);
    let bgColor = lerpColor(murkyColor, clearColor, progress);
    background(bgColor);
  }

  // Fog layer
  let fogAmount = map(trash.length, 0, totalTrash, 0, 120);
  noStroke();
  fill(0, fogAmount);
  rect(0, 0, width, height);

  if (showScoreboard) {
    drawScoreboard();
    return;
  }

  updateParticles();

  // Sunlight rays if ocean mostly clean
  if (progress > 0.7) {
    sunlightAlpha = lerp(sunlightAlpha, 100, 0.01);
    drawSunlightRays(sunlightAlpha);
  }

  imageMode(CENTER);
  for (let t of trash) {
    let floatY = sin(frameCount * 0.05 + t.floatOffset) * 5;
    image(t.img, t.x, t.y + floatY, t.size, t.size);
  }

  // Fish return when ocean is clean
  if (progress >= 1) {
    for (let f of fish) {
      fill(f.color);
      noStroke();
      ellipse(f.x, f.y, f.size * 1.2, f.size);
      f.x += f.speed;
      if (f.x > width + f.size) {
        f.x = -f.size;
        f.y = random(height);
      }
    }
  }

  for (let id in players) {
    let p = players[id];
    p.x = lerp(p.x, p.targetX, 0.1);
    p.y = lerp(p.y, p.targetY, 0.1);

    if (frameCount % 5 === 0) {
      particles.push({ x: p.x, y: p.y, life: 60, color: p.color });
    }

    push();
    translate(p.x, p.y);
    imageMode(CENTER);
    image(netImage, 0, 0, 100, 100);
    fill(255);
    noStroke();
    textAlign(CENTER);
    textSize(24);
    text(p.name, 0, -70);
    pop();

    for (let i = trash.length - 1; i >= 0; i--) {
      let t = trash[i];
      if (dist(p.x, p.y, t.x, t.y) < (50 + t.size / 2)) {
        trash.splice(i, 1);
        socket.emit('tryCollectTrash');
      }
    }
  }

  drawProgressBar(progress);

  if (!oceanSaved && trash.length === 0) {
    oceanSaved = true;
    savedTimer = frameCount;
  }

  if (oceanSaved && frameCount > savedTimer + 60) {
    showScoreboard = true;
    savedTimer = frameCount;
  }
}

function drawProgressBar(progress) {
  let barWidth = width * 0.8;
  let barHeight = 30;
  let x = width / 2 - barWidth / 2;
  let y = 50;

  noFill();
  stroke(255);
  strokeWeight(4);
  rect(x, y, barWidth, barHeight);

  noStroke();
  fill(0, 255, 150);
  rect(x, y, barWidth * progress, barHeight);

  fill(255);
  noStroke();
  textAlign(CENTER, CENTER);
  textSize(24);
  text("Ocean Cleanup Progress", width / 2, y + barHeight + 25);
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    fill(p.color[0], p.color[1], p.color[2], map(p.life, 0, 60, 0, 255));
    noStroke();
    ellipse(p.x, p.y, 10);
    p.life -= 2;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function drawScoreboard() {
  background(0);
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(80);
  text("ðŸŒŸ Ocean Saved! ðŸŒŸ", width / 2, 100);

  textSize(40);
  let sortedPlayers = Object.values(players).sort((a, b) => b.score - a.score);
  let startY = 250;
  for (let i = 0; i < sortedPlayers.length; i++) {
    let p = sortedPlayers[i];
    text(`${i + 1}. ${p.name} - ${p.score} trash collected`, width / 2, startY + i * 60);
  }

  textSize(30);
  text(`Next game starting in ${countdown} seconds...`, width / 2, height - 100);

  if (frameCount % 60 === 0) {
    countdown--;
    if (countdown <= 0) {
      showScoreboard = false;
      oceanSaved = false;
      countdown = 30;
      for (let id in players) {
        players[id].score = 0;
      }
      spawnTrash();
      generateFish();
    }
  }
}

function drawSunlightRays(alpha) {
  push();
  blendMode(ADD);
  noStroke();
  fill(255, 255, 200, alpha);
  for (let i = 0; i < 8; i++) {
    let angle = i * TWO_PI / 8;
    let x = width / 2 + cos(angle) * 800;
    let y = height / 2 + sin(angle) * 800;
    triangle(width / 2, 0, x, y, width / 2, height / 2);
  }
  pop();
}
</script>
</body>
</html>
