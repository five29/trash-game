<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ocean Cleanup Game</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/addons/p5.sound.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    #startOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 48px;
      font-family: sans-serif;
      z-index: 1000;
    }
    #startOverlay.hidden {
      display: none;
    }

html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
  </style>
<script>
function handleStartClick() {
  if (!bgMusicLoaded) return;
  const overlay = document.getElementById('startOverlay');
  overlay.classList.add('hidden');
  if (bgMusic && !bgMusic.isPlaying()) {
    bgMusic.setVolume(0.4);
    bgMusic.loop();
  }
  loop();
  gameStartFrame = frameCount;
}
</script>
</head>
<body>
<div id="startOverlay" onclick="handleStartClick()">Loading...</div>
<script>
let socket;
let players = {};
let trash = [];
let trashImages = [];
let particles = [];
let bubbles = [];
let fish = [];
let fishImages = [];
let totalTrash = 300;
let netImage;
let backgroundImg;
let oceanSaved = false;
let savedTimer = 0;
let showScoreboard = false;
let countdown = 180;
let splash = true;
let shimmerX = 0;
let bgMusic;
let collectSound;
let gameTimer = 120; // 2 minutes
let gameOver = false;
let gameOverTimer = 0;
let gameStartFrame;
let gameOverVideo;
let bgMusicLoaded = false;
let showIntroVideo = false;
let introVideoPlayed = false;
let introVideo;
let grime = 1;

function handleStartClick() {
  if (!bgMusicLoaded) return;
  const overlay = document.getElementById('startOverlay');
  overlay.classList.add('hidden');
  if (bgMusic && !bgMusic.isPlaying()) {
    bgMusic.setVolume(0.4);
    bgMusic.loop();
  }
  loop();
  gameStartFrame = frameCount;
}

function preload() {
  netImage = loadImage('net.png');
  backgroundImg = loadImage('background.png');
  for (let i = 1; i <= 10; i++) {
    trashImages.push(loadImage(`trash${i}.png`));
  }
  // Load fish images
  fishImages = [];
  for (let i = 1; i <= 6; i++) {
    let fishImg = loadImage(`fish${i}.png`, (img) => {
      console.log(`Successfully loaded fish image ${i}:`, {
        width: img.width,
        height: img.height
      });
      fishImages[i-1] = img;
      if (i === 6) {
        generateFish();
      }
    });
  }
  soundFormats('mp3', 'wav');
  bgMusic = loadSound('background-music.mp3', () => {
    bgMusicLoaded = true;
    document.getElementById('startOverlay').innerText = 'Click to Start';
  });
collectSound = loadSound('collect.wav');
}

function setup() {
  createCanvas(4096, 4096);
  introVideo = createVideo('https://earnest-paprenjak-d5e128.netlify.app/gameover.mp4');
  introVideo.size(4096, 4096);
  introVideo.hide();
  socket = io();
  spawnTrash();
  noLoop();
  gameOverVideo = createVideo('https://earnest-paprenjak-d5e128.netlify.app/gameover.mp4');
  gameOverVideo.size(4096, 4096);
  gameOverVideo.hide(); // Hide it by default, we'll show it only at game over

  // Wait for images to load before generating fish
  setTimeout(() => {
    if (fishImages.length === 6) {
      generateFish();
    }
  }, 1000);

  socket.on('playerJoined', ({ id, name }) => {
    // Generate a random color
    const color = [random(255), random(255), random(255)];
    
    players[id] = {
      color: color,
      name: name,
      score: 0,
      x: width / 2,
      y: height / 2,
      targetX: width / 2,
      targetY: height / 2,
      alpha: 0
    };
    // Make the player visible
    players[id].alpha = 255;
    splash = false;
  });

  socket.on('updateGame', ({ id, move }) => {
    if (players[id]) {
      players[id].targetX = move.x * width;
      players[id].targetY = move.y * height;
      console.log(`Player ${id} moved to: ${move.x}, ${move.y}`);
    }
  });

  socket.on('scoreUpdate', ({ id, score }) => {
    if (players[id]) {
      players[id].score = score;
    }
  });

  // === ADD THIS HANDLER TO REMOVE PLAYER ON DISCONNECT ===
  socket.on('playerLeft', (id) => {
    delete players[id];
  });

  // ...rest of your setup() function (if you have more below)
}


function draw() {
  if (!gameStartFrame) gameStartFrame = frameCount;
  let timeElapsed = Math.floor((frameCount - gameStartFrame) / 60);
  let timeLeft = max(0, gameTimer - timeElapsed);

  clear();
  push();
  drawingContext.save();
  drawingContext.beginPath();
  drawingContext.arc(width / 2, height / 2, height / 2, 0, TWO_PI);
  drawingContext.clip();

  let progress = 1 - (trash.length / totalTrash);
  const playerCount = Object.keys(players).length;
  let grimeRate = constrain(trash.length / totalTrash, 0, 1);
  let rate = map(grimeRate, 0, 1, 180, 60) - playerCount * 10;
  rate = constrain(rate, 30, 300);

  
  if (backgroundImg) {
    imageMode(CORNER);
    image(backgroundImg, 0, 0, width, height);
  } else {
    background(0, 100, 200);
  }

  grime = lerp(grime, constrain(trash.length / totalTrash, 0, 1), 0.05);
let fogColor = lerpColor(color(5, 35, 10, 255), color(0, 180, 255, 0), 1 - grime);
  noStroke();
  fill(fogColor);
  rect(0, 0, width, height);

  updateBubbles();
  updateParticles();

  for (let f of fish) {
    // Use a random fish image
    let fishImage = fishImages[f.imageIndex];
    if (fishImage && fishImage.width > 0 && fishImage.height > 0) {
      // Scale the image based on the fish's size
      let scale = f.size / fishImage.width;
      push();
      translate(f.x, f.y);
      rotate(f.rotation);
      image(fishImage, 0, 0, fishImage.width * scale, fishImage.height * scale);
      pop();
    } else {
      console.log('Invalid fish image:', f.imageIndex, fishImage);
    }

    // Update fish position
    if (f.imageIndex === 0) { // Crab (index 0)
      // Stay static on the ocean floor
      let centerX = width / 2;
      let centerY = height / 2;
      let radius = height / 2 - 100;
      
      // Keep crab on the edge
      let angle = atan2(f.y - centerY, f.x - centerX);
      f.x = centerX + cos(angle) * radius;
      f.y = centerY + sin(angle) * radius;
      
      // Keep rotation facing forward
      f.rotation = angle + PI/2; // Face forward
    } else if (f.imageIndex === 1) { // Eel (index 1)
      // Create subtle wavy effect for eel
      
      // Add subtle wavy motion
      let waveOffset = frameCount * 0.05; // Slower wave speed
      f.y += sin(waveOffset) * 2; // Smaller up/down wave
      f.x += cos(waveOffset) * 1.5; // Smaller side-to-side wave
      
      // Add subtle wavy rotation
      f.rotation = f.rotation + sin(waveOffset) * 0.05;
      
      // Keep eel within bounds
      let centerX = width / 2;
      let centerY = height / 2;
      let radius = height / 2 - 100;
      let distFromCenter = dist(f.x, f.y, centerX, centerY);
      if (distFromCenter > radius) {
        let angle = random(TWO_PI);
        let r = random(radius);
        f.x = centerX + cos(angle) * r;
        f.y = centerY + sin(angle) * r;
        f.rotation = angle + random(-PI/4, PI/4);
      }
    } else if (f.imageIndex === 2 || f.imageIndex === 4) { // Fish 3 and 5 (index 2 and 4)
      // Move horizontally from left to right with natural movement
      f.x += f.speed;
      f.y += random(-1, 1); // Small up/down movement
      f.rotation = 0; // Face forward
      
      if (f.x > width) {
        f.x = 0; // Reset to left side when off screen
        f.y = random(height * 0.2, height * 0.8); // Random y position in middle of screen
      }
    } else {
      // Normal fish movement
      f.x += f.speed * cos(f.rotation);
      f.y += f.speed * sin(f.rotation);
      f.rotation += f.rotationSpeed;
      
      let centerX = width / 2;
      let centerY = height / 2;
      let radius = height / 2 - 100;
      let distFromCenter = dist(f.x, f.y, centerX, centerY);
      if (distFromCenter > radius) {
        let angle = random(TWO_PI);
        let r = random(radius);
        f.x = centerX + cos(angle) * r;
        f.y = centerY + sin(angle) * r;
        f.rotation = angle + random(-PI/4, PI/4); // Set rotation to face direction of movement
      }
    }
  }

  while (fish.length < 20) {
    let angle = random(TWO_PI);
    let r = random(height / 2 - 100);
    let x = width / 2 + cos(angle) * r;
    let y = height / 2 + sin(angle) * r;
    fish.push({
      x: x,
      y: y,
      speed: random(0.5, 1.5),
      size: random(40, 80),
      imageIndex: floor(random(fishImages.length)),
      rotation: random(TWO_PI),
      rotationSpeed: random(-0.02, 0.02)
    });
  }

  imageMode(CENTER);
  for (let t of trash) {
    let floatY = sin(frameCount * 0.05 + t.floatOffset) * 5;

noTint();
image(t.img, t.x, t.y + floatY, t.size, t.size);

    noTint();
    image(t.img, t.x, t.y + floatY, t.size, t.size);
  }

  for (let id in players) {
    let p = players[id];
    let centerX = width / 2;
    let centerY = height / 2;
    let radius = height / 2 - 150;
    let targetDist = dist(p.targetX, p.targetY, centerX, centerY);
    if (targetDist > radius) {
      let angle = atan2(p.targetY - centerY, p.targetX - centerX);
      p.targetX = centerX + cos(angle) * radius;
      p.targetY = centerY + sin(angle) * radius;
    }
    p.x = lerp(p.x, p.targetX, 0.1);
    p.y = lerp(p.y, p.targetY, 0.1);
    if (p.alpha < 255) p.alpha += 5;

    if (frameCount % 6 === 0) {
      bubbles.push({ x: p.x + random(-10, 10), y: p.y + 30, size: random(10, 20), life: 60, color: [200, 255, 255] });
    }
    if (frameCount % 5 === 0) {
      particles.push({ x: p.x, y: p.y, life: 60, color: p.color });
    }

    // Draw player
    push();
    translate(p.x, p.y);
    
    // Draw solid colored circle around net
    fill(p.color[0], p.color[1], p.color[2], 150); // Semi-transparent fill
    noStroke();
    ellipse(0, 0, 120, 120);
    
    // Draw net
    tint(255, p.alpha);
    image(netImage, 0, 0, 100, 100);
    noTint();
    
    // Draw name
    fill(255, p.alpha);
    noStroke();
    textAlign(CENTER);
    textSize(32);
    textStyle(BOLD);
    text(p.name, 0, -70);
    pop();

    for (let i = trash.length - 1; i >= 0; i--) {
  let t = trash[i];
  if (dist(p.x, p.y, t.x, t.y) < (50 + t.size / 2)) {
    // ---- PARTICLE BURST EFFECT ----
    for (let j = 0; j < 20; j++) {
      let angle = random(TWO_PI);
      let speed = random(4, 10);
      particles.push({
        x: t.x,
        y: t.y,
        dx: cos(angle) * speed,
        dy: sin(angle) * speed,
        life: 30,
        color: [random(180,255), random(180,255), 0]
      });
    }
    // ------------------------------
    trash.splice(i, 1);
if (collectSound && collectSound.isLoaded()) collectSound.play();
    socket.emit('tryCollectTrash');
  }
}

  }

  let topPlayer = Object.values(players).sort((a, b) => b.score - a.score)[0];
  if (topPlayer) {
    fill(255);
    textAlign(CENTER, CENTER);
    textSize(40);
    text(`Leader: ${topPlayer.name}`, width / 2, height - 260);
  }
// Draw countdown timer
fill(255);
textAlign(CENTER, CENTER);
textSize(70);
text(`${timeLeft}`, width / 2, 160);

  if (!oceanSaved && trash.length === 0) {
    oceanSaved = true;
    savedTimer = frameCount;
  }

  if (oceanSaved && frameCount > savedTimer + 60) {
    showScoreboard = true;
    savedTimer = frameCount;
  }

  if (showScoreboard) {
    drawScoreboard();
    if (frameCount > savedTimer + 120) { // Hide scoreboard after 2 seconds
      showScoreboard = false;
    }
  }
  drawingContext.restore();
  pop();

  if (timeLeft === 0 && !gameOver) {
    gameOver = true;
    gameOverTimer = frameCount;
  }

if (gameOver && frameCount - gameOverTimer < 1800) {
  // SHOW the game over video
  if (gameOverVideo) {
    gameOverVideo.show();
    gameOverVideo.loop();
    image(gameOverVideo, 0, 0, width, height);
  }
  // Draw the overlay and text
  push();
  fill(0, 0, 0, 180);
  rect(0, 0, width, height);
  fill(255);
  textSize(100);
  textAlign(CENTER, CENTER);
  text("GAME OVER", width / 2, height / 2);

  // -- WINNER name just below GAME OVER --
  let topPlayer = Object.values(players).sort((a, b) => b.score - a.score)[0];
  if (topPlayer && topPlayer.name) {
    textSize(55);
    fill(255, 215, 0); // Gold color for winner
    text(`Winner: ${topPlayer.name}`, width / 2, height / 2 + 70);
  }

  textSize(40);
  fill(255);
  let secondsLeft = Math.ceil((1800 - (frameCount - gameOverTimer)) / 60);
  // Moved down by 60 more px to make room for winner
  text(`Next game starts in ${secondsLeft}`, width / 2, height / 2 + 140);
  pop();
} else if (gameOver && frameCount - gameOverTimer >= 180) {
  socket.emit('kickAll');
  // Reset game state
  gameOver = false;
  oceanSaved = false;
  showScoreboard = false;
  savedTimer = 0;
  gameStartFrame = frameCount;
  trash = [];
  spawnTrash();
  particles = [];
  bubbles = [];
  fish = [];
  generateFish();
}
}

function spawnTrash() {
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = height / 2 - 100;
  while (trash.length < totalTrash) {
    let angle = random(TWO_PI);
    let r = random(radius);
    let x = centerX + cos(angle) * r;
    let y = centerY + sin(angle) * r;
    trash.push({
      x: x,
      y: y,
      size: random(80, 60),
      img: random(trashImages),
      floatOffset: random(1000)
    });
  }
}

function generateFish() {
  fish = [];
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = height / 2 - 100;
  
  // Add more crabs around the edge
  for (let i = 0; i < 8; i++) { // 8 crabs
    let angle = i * (TWO_PI / 8); // Evenly spaced around the circle
    let x = centerX + cos(angle) * radius;
    let y = centerY + sin(angle) * radius;
    fish.push({
      x: x,
      y: y,
      speed: 0.5, // Slower speed for crabs
      size: random(30, 50), // Smaller size range for crabs
      imageIndex: 0, // Crab image
      rotation: angle + PI/2, // Face forward
      rotationSpeed: 0 // No rotation
    });
  }
  
  // Add other fish with unique size ranges
  for (let i = 0; i < 12; i++) { // Reduced number of other fish
    let angle = random(TWO_PI);
    let r = random(radius);
    let x = centerX + cos(angle) * r;
    let y = centerY + sin(angle) * r;
    
    // Determine size based on fish type
    let sizeRange;
    switch (floor(random(1, fishImages.length))) {
      case 1: // Eel
        sizeRange = random(60, 100); // Larger size for eel
        break;
      case 2: // Fish 3
        sizeRange = random(40, 70); // Medium size
        break;
      case 3: // Fish 4
        sizeRange = random(50, 80); // Medium-large size
        break;
      case 4: // Fish 5
        sizeRange = random(30, 60); // Smaller size
        break;
      case 5: // Fish 6
        sizeRange = random(45, 75); // Medium size
        break;
      default:
        sizeRange = random(40, 80); // Default size range
    }
    
    fish.push({
      x: x,
      y: y,
      speed: random(0.5, 1.5),
      size: sizeRange,
      imageIndex: floor(random(1, fishImages.length)), // Skip crab image
      rotation: angle, // Start facing their initial direction
      rotationSpeed: random(-0.01, 0.01) // Slower rotation for more natural movement
    });
  }
  console.log('Generated fish:', fish);
}

function updateBubbles() {
  for (let i = bubbles.length - 1; i >= 0; i--) {
    let b = bubbles[i];
    fill(b.color[0], b.color[1], b.color[2], map(b.life, 0, 60, 0, 180));
    noStroke();
    ellipse(b.x, b.y, b.size);
    b.y -= 0.5;
    b.size *= 0.98;
    b.life -= 1;
    if (b.life <= 0) {
      bubbles.splice(i, 1);
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    fill(p.color[0], p.color[1], p.color[2], map(p.life, 0, 30, 0, 255));
    noStroke();
    ellipse(p.x, p.y, 8, 8);
    // Move sparkle if has dx/dy (sparkle burst)
    if ('dx' in p) p.x += p.dx;
    if ('dy' in p) p.y += p.dy;
    if ('dx' in p) p.dx *= 0.85;
    if ('dy' in p) p.dy *= 0.85;
    p.life -= 1;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}
</script>
<div id="qr-container" style="position:fixed; left:30.2%; bottom:40px; transform:translate(-50%,0); background:rgba(255,255,255,0.9); padding:18px; border-radius:20px; z-index:9999; display:flex; flex-direction:column; align-items:center;">
  <div style="color:#000; font-size: 20px; margin-bottom: 10px; font-family: sans-serif;">
    <strong>Scan to Play!</strong>
  </div>
  <div id="qrcode"></div>
  <div style="color:#444; font-size: 12px; margin-top: 5px; font-family: sans-serif;">
    Or go to:<br>
    <span id="qr-url"></span>
  </div>
</div>
<!-- QRCode.js library from CDN -->
<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
<script>
  // Make the link for the QR code (this uses your current address!)
 var qrURL = "https://trash-game-1q5m.onrender.com/controller.html";
  document.getElementById("qr-url").textContent = qrURL;
  new QRCode(document.getElementById("qrcode"), {
    text: qrURL,
    width: 240,
    height: 240
  });
</script>
</body>
</html>
